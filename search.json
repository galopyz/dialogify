[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "The Python Standard Library documentation is very helpful for learning Python. So is Solveit! Solveit is jupyter notebook + AI with superpowers. Learning programming is so much fun and productive with AI. Therefore, I wanted to convert these html python documentation pages into solveit dialogues, which comprise small pieces of notes and code messages with appropriate headings, which can be extracted from the pages’ table of contents.\nHow it works:\n\nWe first get the html from the python documentation web page.\nWe turn it into (msg_type, element) where msg_type is note or code and element is soup element.\nTurn elements into appropriate solveit messages for the dialog.\n\nThe goal is to use # for the title, ## for subheading, and ### for each function definition from the docs.\nFirst, we grab html from the documentation and create soup.\n\ndoc_url = 'https://docs.python.org/3/library/random.html'\ndoc_html = httpx.get(doc_url).text\ndoc_html[:600]\n\n'&lt;!DOCTYPE html&gt;\\n\\n&lt;html lang=\"en\" data-content_root=\"../\"&gt;\\n  &lt;head&gt;\\n    &lt;meta charset=\"utf-8\" /&gt;\\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt;\\n&lt;meta property=\"og:title\" content=\"random — Generate pseudo-random numbers\" /&gt;\\n&lt;meta property=\"og:type\" content=\"website\" /&gt;\\n&lt;meta property=\"og:url\" content=\"https://docs.python.org/3/library/random.html\" /&gt;\\n&lt;meta property=\"og:site_name\" content=\"Python documentation\" /&gt;\\n&lt;meta property=\"og:description\" content=\"Source code: Lib/random.py This module imple'\n\n\n\nsoup = BeautifulSoup(doc_html, 'html.parser')",
    "crumbs": [
      "core"
    ]
  },
  {
    "objectID": "core.html#introduction",
    "href": "core.html#introduction",
    "title": "core",
    "section": "",
    "text": "The Python Standard Library documentation is very helpful for learning Python. So is Solveit! Solveit is jupyter notebook + AI with superpowers. Learning programming is so much fun and productive with AI. Therefore, I wanted to convert these html python documentation pages into solveit dialogues, which comprise small pieces of notes and code messages with appropriate headings, which can be extracted from the pages’ table of contents.\nHow it works:\n\nWe first get the html from the python documentation web page.\nWe turn it into (msg_type, element) where msg_type is note or code and element is soup element.\nTurn elements into appropriate solveit messages for the dialog.\n\nThe goal is to use # for the title, ## for subheading, and ### for each function definition from the docs.\nFirst, we grab html from the documentation and create soup.\n\ndoc_url = 'https://docs.python.org/3/library/random.html'\ndoc_html = httpx.get(doc_url).text\ndoc_html[:600]\n\n'&lt;!DOCTYPE html&gt;\\n\\n&lt;html lang=\"en\" data-content_root=\"../\"&gt;\\n  &lt;head&gt;\\n    &lt;meta charset=\"utf-8\" /&gt;\\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt;\\n&lt;meta property=\"og:title\" content=\"random — Generate pseudo-random numbers\" /&gt;\\n&lt;meta property=\"og:type\" content=\"website\" /&gt;\\n&lt;meta property=\"og:url\" content=\"https://docs.python.org/3/library/random.html\" /&gt;\\n&lt;meta property=\"og:site_name\" content=\"Python documentation\" /&gt;\\n&lt;meta property=\"og:description\" content=\"Source code: Lib/random.py This module imple'\n\n\n\nsoup = BeautifulSoup(doc_html, 'html.parser')",
    "crumbs": [
      "core"
    ]
  },
  {
    "objectID": "core.html#some-helpful-utilities",
    "href": "core.html#some-helpful-utilities",
    "title": "core",
    "section": "Some helpful utilities",
    "text": "Some helpful utilities\nHere are some utility functions for getting the main content, cleaning text, getting title, etc.\n\nsource\n\nget_main\n\ndef get_main(\n    soup\n):\n\nExtract the main content section from Python docs soup\n\nms = get_main(soup); str(ms)[:300]\n\n'&lt;section id=\"module-random\"&gt;\\n&lt;span id=\"random-generate-pseudo-random-numbers\"&gt;&lt;/span&gt;&lt;h1&gt;&lt;code class=\"xref py py-mod docutils literal notranslate\"&gt;&lt;span class=\"pre\"&gt;random&lt;/span&gt;&lt;/code&gt; — Generate pseudo-random numbers&lt;a class=\"headerlink\" href=\"#module-random\" title=\"Link to this heading\"&gt;¶&lt;/a&gt;&lt;/h1'\n\n\n\nsource\n\n\nclean_txt\n\ndef clean_txt(\n    el\n):\n\nClean element text by removing paragraph signs and extra whitespace\n\nsource\n\n\nget_title\n\ndef get_title(\n    section\n):\n\nExtract the h1 title from a section\n\nget_title(ms)\n\n'random — Generate pseudo-random numbers'\n\n\nBefore turning the soup into markdown, we turn these into each sections as in (title, section) tuples.\n\nsource\n\n\nget_sections\n\ndef get_sections(\n    main\n):\n\nGet all direct child sections as (title, section_element) tuples\n\nlen(get_sections(ms))\n\n12\n\n\nWe can grab sections and grab the bookkeeping section\n\nsts = get_sections(ms)\nbk = sts[0][1]\nstr(bk)[:300]\n\n'&lt;section id=\"bookkeeping-functions\"&gt;\\n&lt;h2&gt;Bookkeeping functions&lt;a class=\"headerlink\" href=\"#bookkeeping-functions\" title=\"Link to this heading\"&gt;¶&lt;/a&gt;&lt;/h2&gt;\\n&lt;dl class=\"py function\"&gt;\\n&lt;dt class=\"sig sig-object py\" id=\"random.seed\"&gt;\\n&lt;span class=\"sig-prename descclassname\"&gt;&lt;span class=\"pre\"&gt;random.&lt;/span&gt;&lt;'\n\n\nLooking at the preview to check if it is looking good.\n\nsource\n\n\npreview_msgs\n\ndef preview_msgs(\n    msgs\n):\n\nPreview message tuples as rendered markdown\n\npreview_msgs(get_sections(ms)[:2])\n\n[Bookkeeping functions]\n\n\nBookkeeping functions¶\n\n\n\nrandom.seed(a=None, version=2)¶\n\n\n\nInitialize the random number generator.\n\n\nIf a is omitted or None, the current system time is used. If randomness sources are provided by the operating system, they are used instead of the system time (see the os.urandom() function for details on availability).\n\n\nIf a is an int, its absolute value is used directly.\n\n\nWith version 2 (the default), a str, bytes, or bytearray object gets converted to an int and all of its bits are used.\n\n\nWith version 1 (provided for reproducing random sequences from older versions of Python), the algorithm for str and bytes generates a narrower range of seeds.\n\n\n\nChanged in version 3.2: Moved to the version 2 scheme which uses all of the bits in a string seed.\n\n\n\n\nChanged in version 3.11: The seed must be one of the following types: None, int, float, str, bytes, or bytearray.\n\n\n\n\n\n\nrandom.getstate()¶\n\n\n\nReturn an object capturing the current internal state of the generator. This object can be passed to setstate() to restore the state.\n\n\n\n\n\nrandom.setstate(state)¶\n\n\n\nstate should have been obtained from a previous call to getstate(), and setstate() restores the internal state of the generator to what it was at the time getstate() was called.\n\n\n\n\n\n\n[Functions for bytes]\n\n\nFunctions for bytes¶\n\n\n\nrandom.randbytes(n)¶\n\n\n\nGenerate n random bytes.\n\n\nThis method should not be used for generating security tokens. Use secrets.token_bytes() instead.\n\n\n\nAdded in version 3.9.\n\n\n\n\n\n\n\nhtml_to_md turns html into md for appropriate tags.\n\nsource\n\n\nhtml_to_md\n\ndef html_to_md(\n    el, in_link:bool=False\n):\n\nRecursively convert HTML element to markdown string\n\nsource\n\n\nhtml_to_md_children\n\ndef html_to_md_children(\n    el, in_link:bool=False\n):\n\nConvert all children of an HTML element to markdown\n\nprint(html_to_md(bk))\n\n\nBookkeeping functions[¶](#bookkeeping-functions)\n\n\nrandom.seed(*a=None*, *version=2*)[¶](#random.seed)\nInitialize the random number generator.\nIf *a* is omitted or `None`, the current system time is used.  If\nrandomness sources are provided by the operating system, they are used\ninstead of the system time (see the [os.urandom()](os.html#os.urandom) function for details\non availability).\nIf *a* is an int, its absolute value is used directly.\nWith version 2 (the default), a [str](stdtypes.html#str), [bytes](stdtypes.html#bytes), or [bytearray](stdtypes.html#bytearray)\nobject gets converted to an [int](functions.html#int) and all of its bits are used.\nWith version 1 (provided for reproducing random sequences from older versions\nof Python), the algorithm for [str](stdtypes.html#str) and [bytes](stdtypes.html#bytes) generates a\nnarrower range of seeds.\n\nChanged in version 3.2: Moved to the version 2 scheme which uses all of the bits in a string seed.\n\n\nChanged in version 3.11: The *seed* must be one of the following types:\n`None`, [int](functions.html#int), [float](functions.html#float), [str](stdtypes.html#str),\n[bytes](stdtypes.html#bytes), or [bytearray](stdtypes.html#bytearray).\n\n\n\n\nrandom.getstate()[¶](#random.getstate)\nReturn an object capturing the current internal state of the generator.  This\nobject can be passed to [setstate()](#random.setstate) to restore the state.\n\n\n\nrandom.setstate(*state*)[¶](#random.setstate)\n*state* should have been obtained from a previous call to [getstate()](#random.getstate), and\n[setstate()](#random.setstate) restores the internal state of the generator to what it was at\nthe time [getstate()](#random.getstate) was called.",
    "crumbs": [
      "core"
    ]
  },
  {
    "objectID": "core.html#soup-to-msg_type-el",
    "href": "core.html#soup-to-msg_type-el",
    "title": "core",
    "section": "soup to (msg_type, el)",
    "text": "soup to (msg_type, el)\nSolveit messages have Code, Note, Prompt, and Raw for message types. But we want to focus on note and code for creating dialogs. By turning soup into (msg_type, el), we can easily turn those into sovleit messages with markdown.\n\nsource\n\nhas_cls\n\ndef has_cls(\n    el, cls\n):\n\nCheck if element has a specific CSS class\ndt is special because it is used for function definition in python docs.\n\nsource\n\n\nget_msg_type\n\ndef get_msg_type(\n    el\n):\n\nDetermine message type (‘note’, ‘code’, or ‘dt’) for an HTML element\n\nsource\n\n\ncollect_msgs\n\ndef collect_msgs(\n    el\n):\n\nRecursively collect (msg_type, element) tuples from HTML tree\n\nsource\n\n\nformat_msg\n\ndef format_msg(\n    msg_type, el\n):\n\nConvert (msg_type, element) tuple to (msg_type, markdown_string)\n\nsource\n\n\ntable_to_md\n\ndef table_to_md(\n    table\n):\n\nConvert HTML table to markdown format\nSome functions/classes on the doc has multiple signatures. In this case, dts need to be merged into a single message as a heading.\n\nsource\n\n\nmerge_dt\n\ndef merge_dt(\n    msgs\n):\n\nMerge consecutive ‘dt’ messages into single heading notes\n\nsource\n\n\nformat_msgs\n\ndef format_msgs(\n    el\n):\n\nConvert HTML element to list of formatted (msg_type, markdown) tuples\nLet’s try it on bytearray function from the “https://docs.python.org/3.12/library/functions.html”.\n\nbytearray_html = '''&lt;dl class=\"py class\" id=\"func-bytearray\"&gt;\n&lt;dt class=\"sig sig-object py\"&gt;\n&lt;em class=\"property\"&gt;&lt;span class=\"k\"&gt;&lt;span class=\"pre\"&gt;class&lt;/span&gt;&lt;/span&gt;&lt;span class=\"w\"&gt; &lt;/span&gt;&lt;/em&gt;&lt;span class=\"sig-name descname\"&gt;&lt;span class=\"pre\"&gt;bytearray&lt;/span&gt;&lt;/span&gt;&lt;span class=\"sig-paren\"&gt;(&lt;/span&gt;&lt;em class=\"sig-param\"&gt;&lt;span class=\"n\"&gt;&lt;span class=\"pre\"&gt;source&lt;/span&gt;&lt;/span&gt;&lt;span class=\"o\"&gt;&lt;span class=\"pre\"&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=\"default_value\"&gt;&lt;span class=\"pre\"&gt;b''&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span class=\"sig-paren\"&gt;)&lt;/span&gt;&lt;/dt&gt;\n&lt;dt class=\"sig sig-object py\"&gt;\n&lt;em class=\"property\"&gt;&lt;span class=\"k\"&gt;&lt;span class=\"pre\"&gt;class&lt;/span&gt;&lt;/span&gt;&lt;span class=\"w\"&gt; &lt;/span&gt;&lt;/em&gt;&lt;span class=\"sig-name descname\"&gt;&lt;span class=\"pre\"&gt;bytearray&lt;/span&gt;&lt;/span&gt;&lt;span class=\"sig-paren\"&gt;(&lt;/span&gt;&lt;em class=\"sig-param\"&gt;&lt;span class=\"n\"&gt;&lt;span class=\"pre\"&gt;source&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;, &lt;em class=\"sig-param\"&gt;&lt;span class=\"n\"&gt;&lt;span class=\"pre\"&gt;encoding&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span class=\"sig-paren\"&gt;)&lt;/span&gt;&lt;/dt&gt;\n&lt;dt class=\"sig sig-object py\"&gt;\n&lt;em class=\"property\"&gt;&lt;span class=\"k\"&gt;&lt;span class=\"pre\"&gt;class&lt;/span&gt;&lt;/span&gt;&lt;span class=\"w\"&gt; &lt;/span&gt;&lt;/em&gt;&lt;span class=\"sig-name descname\"&gt;&lt;span class=\"pre\"&gt;bytearray&lt;/span&gt;&lt;/span&gt;&lt;span class=\"sig-paren\"&gt;(&lt;/span&gt;&lt;em class=\"sig-param\"&gt;&lt;span class=\"n\"&gt;&lt;span class=\"pre\"&gt;source&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;, &lt;em class=\"sig-param\"&gt;&lt;span class=\"n\"&gt;&lt;span class=\"pre\"&gt;encoding&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;, &lt;em class=\"sig-param\"&gt;&lt;span class=\"n\"&gt;&lt;span class=\"pre\"&gt;errors&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span class=\"sig-paren\"&gt;)&lt;/span&gt;&lt;/dt&gt;\n&lt;dd&gt;&lt;p&gt;Return a new array of bytes.&lt;/p&gt;\n&lt;p&gt;The optional &lt;em&gt;source&lt;/em&gt; parameter can be used to initialize the array:&lt;/p&gt;\n&lt;ul class=\"simple\"&gt;\n&lt;li&gt;&lt;p&gt;If it is a &lt;em&gt;string&lt;/em&gt;, you must also give the &lt;em&gt;encoding&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;If it is an &lt;em&gt;integer&lt;/em&gt;, the array will have that size.&lt;/p&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Without an argument, an array of size 0 is created.&lt;/p&gt;\n&lt;/dd&gt;&lt;/dl&gt;'''\n\n\nba_soup = BeautifulSoup(bytearray_html, 'html.parser')\npreview_msgs(collect_msgs(ba_soup.dl))\n\n[dt]\n\nclass bytearray(source=b’’)\n\n\n\n[dt]\n\nclass bytearray(source, encoding)\n\n\n\n[dt]\n\nclass bytearray(source, encoding, errors)\n\n\n\n[note]\n\nReturn a new array of bytes.\n\n\n\n[note]\n\nThe optional source parameter can be used to initialize the array:\n\n\n\n[note]\n\n\n\nIf it is a string, you must also give the encoding.\n\n\n\n\nIf it is an integer, the array will have that size.\n\n\n\n\n\n[note]\n\nWithout an argument, an array of size 0 is created.\n\n\n\n\nba_msgs = format_msgs(ba_soup)\nba_msgs\n\n[('note',\n  \"### `class bytearray(source=b'')`\\n### `class bytearray(source, encoding)`\\n### `class bytearray(source, encoding, errors)`\"),\n ('note', 'Return a new array of bytes.'),\n ('note',\n  'The optional *source* parameter can be used to initialize the array:'),\n ('note',\n  '\\n- If it is a *string*, you must also give the *encoding*.\\n- If it is an *integer*, the array will have that size.\\n'),\n ('note', 'Without an argument, an array of size 0 is created.')]\n\n\n\nmerge_dt(ba_msgs)\n\n[('note',\n  \"### `class bytearray(source=b'')`\\n### `class bytearray(source, encoding)`\\n### `class bytearray(source, encoding, errors)`\"),\n ('note', 'Return a new array of bytes.'),\n ('note',\n  'The optional *source* parameter can be used to initialize the array:'),\n ('note',\n  '\\n- If it is a *string*, you must also give the *encoding*.\\n- If it is an *integer*, the array will have that size.\\n'),\n ('note', 'Without an argument, an array of size 0 is created.')]\n\n\n\npreview_msgs(format_msgs(ba_soup))\n\n[note]\n\nclass bytearray(source=b'')\n\n\nclass bytearray(source, encoding)\n\n\nclass bytearray(source, encoding, errors)\n\n\n\n[note]\nReturn a new array of bytes.\n\n\n[note]\nThe optional source parameter can be used to initialize the array:\n\n\n[note]\n\nIf it is a string, you must also give the encoding.\nIf it is an integer, the array will have that size.\n\n\n\n[note]\nWithout an argument, an array of size 0 is created.\n\n\nLooks good! We can use create_msg to create solveit messages.\n\nsource\n\n\ncreate_msgs\n\ndef create_msgs(\n    doc_tuples, dname:str='', kwargs:VAR_KEYWORD\n):\n\nCreate solveit messages from list of (msg_type, content) tuples\n\n# create_msgs(format_msgs(ms))\n\nAnd we can make dialogs.\n\nsource\n\n\nmk_dialog\n\ndef mk_dialog(\n    url, dname:str=''\n):\n\nFetch Python docs URL and create a solveit dialog from it\nHere are examples to create solveit dialogs:\n\n# mk_dialog('https://docs.python.org/3.12/library/functions.html', dname='dialogify/testing')\n\n\n# mk_dialog('https://docs.python.org/3.12/howto/regex.html#regex-howto', dname='dialogify/regex_howto')\n\n\n# mk_dialog('https://docs.python.org/3.12/howto/regex.html#regex-howto')",
    "crumbs": [
      "core"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "dialogify",
    "section": "",
    "text": "The Python Standard Library documentation is very helpful for learning Python. So is Solveit! Solveit is jupyter notebook + AI with superpowers. Learning programming is so much fun and productive with AI. Therefore, I wanted to convert these html python documentation pages into solveit dialogues, which comprise small pieces of notes and code messages with appropriate headings, which can be extracted from the pages’ table of contents.\nHow it works:\nThe goal is to use # for the title, ## for subheading, and ### for each function definition from the docs.",
    "crumbs": [
      "dialogify"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "dialogify",
    "section": "Installation",
    "text": "Installation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/galopyz/dialogify.git\nor from pypi\n$ pip install dialogify",
    "crumbs": [
      "dialogify"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "dialogify",
    "section": "How to use",
    "text": "How to use\nTo create a solveit dialog from python documentation, we need to pass the url to mk_dialog. Below code creates solveit messages after that message.\nfrom dialogify.core import *\n\nmk_dialog('https://docs.python.org/3.12/library/random.html')\nHere is an example dialog on solveit from random python libary. It also works on Built-in Functions.",
    "crumbs": [
      "dialogify"
    ]
  }
]